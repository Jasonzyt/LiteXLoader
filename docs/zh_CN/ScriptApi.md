# LiteXLoader - 脚本辅助接口文档

[<< 返回目录](Development.md)

下列这些内容，为脚本插件提供了大量的**辅助功能**，包括日志功能、异步接口等等。  
他们让你开发脚本变得更加容易而自然，避免了很多无谓的细节问题的纠缠。

<br>

## 📝 输出信息到控制台

这是为了方便输出信息而设计的便捷函数

`log(data1,data2,...)` (Lua环境下别名：`print`)

- 参数：
  - 待输出的变量或者数据  
    可以是任意类型，参数数量可以是任意个
- 返回值：无

<br>

------

## 💼 脚本辅助 API

下面这些API为脚本增加了必要的辅助接口

### 推迟一段时间执行函数  

`setTimeout(func,msec)`

- 参数：

  - func : `Function`  
    待执行的函数

  - msec : `Integer`  
    推迟执行的时间（毫秒）
- 返回值：此任务ID
- 返回值类型：`Integer`
  - 如果返回`Null`，则代表创建任务失败

<br>

### 推迟一段时间执行代码段（eval）  

`setTimeout(code,msec)`

- 参数：

  - code : `String`  
    待执行的代码段

  - msec : `Integer`  
    推迟执行的时间（毫秒）
- 返回值：此任务ID
- 返回值类型：`Integer`
  - 如果返回`Null`，则代表创建任务失败

<br>

### 设置周期执行函数  

`setInterval(func,msec)`

- 参数：
  - func : `Function`  
    待执行的函数

  - msec : `Integer`  
    执行间隔周期（毫秒）
- 返回值：此任务ID
- 返回值类型： `Integer`

<br>

### 设置周期执行代码段（eval）  

`setInterval(code,msec)`

- 参数：
  - code : `String`  
    待执行的代码段

  - msec : `Integer`  
    执行间隔周期（毫秒）
- 返回值：此任务ID
- 返回值类型： `Integer`
  - 如果返回`Null`，则代表创建任务失败

<br>

### 取消延时 / 周期执行项  

`clearInterval(taskid)`

- 参数：
  - timerid : `Integer`  
    由前几个函数返回的任务ID
- 返回值：是否取消成功
- 返回值类型： `Boolean`
  - 如果返回`Null`，则代表创建任务失败

<br>

------

## 📅 通用日志 API

以往，按某种格式输出日志到指定位置是一件非常麻烦的事情。  
如今，LXL为你提供了方便的通用日志接口。  

### 概念：关于日志等级

为了给日志的优先程度和重要性进行分级，我们引入了 **日志等级** 的概念。  
重要程度不同的日志对应了不同的日志等级，重要性越大，日志等级越高。  
详见下表：

| 日志输出等级 | 0          | 1         | 2         | 3          | 4              |
| ------------ | ---------- | --------- | --------- | ---------- | -------------- |
| 日志类型     | Debug 调试 | Info 提示 | Warn 警告 | Error 错误 | Fatal 严重错误 |

在通用日志 API 中，可以设置日志的**最小输出等级**。  
只有**大于等于**最小输出等级的日志才会被输出，由此，你可以很方便地过滤掉某些在生产环境中没必要输出的信息。  
当最小输出等级设置为5及以上时，所有的日志都将被禁止输出。  
当然，下面将提到的普通文本日志`logger.log`将总是被输出，不受这里设置的影响

默认，最小日志输出等级为1。这代表除了调试信息以外其他种类的日志都将被输出。  
你可以在下面对这些设置进行修改。

<br>

### 设置输出配置

在使用通用日志接口之前，你需要先按你的需求修改一下日志输出的某些配置设置

你可以通过修改设置，自由选择将日志发向控制台、文件甚至某个玩家  
这些设置是可以同时存在的，比如说，你可以设置同时发送到控制台和文件  
如果你不修改任何设置，默认情况下，日志仅会输出到控制台。

#### 设置日志是否输出到控制台

`logger.setConsole(isOpen[,logLevel])`

- 参数：
  - isOpen : `Boolean`  
    设置日志是否输出到控制台  
    开关默认是打开状态。
  - logLevel : `Integer`  
    （可选参数）控制台的最小日志输出等级，默认为1  
- 返回值：无

<br>

#### 设置日志是否输出到文件

`logger.setFile(filepath[,logLevel])`

- 参数：
  - filepath : `String`  
    设置日志输出到的文件路径  
    如果传入空字符串或者null，则代表关闭输出到文件。  
    开关默认是关闭状态
  - logLevel : `Integer`  
    （可选参数）文件的最小日志输出等级，默认为1  
- 返回值：无

如果要输出到文件，我们提倡您将日志统一输出到`BDS根目录/logs/`文件夹下，以方便整理和检查。

<br>

#### 设置日志是否输出到某个玩家

`logger.setPlayer(player[,logLevel])`

- 参数：
  - player : `Player`  
    设置日志输出到的目标玩家对象  
    如果传入null，则代表关闭输出到玩家。默认为关
  - logLevel : `Integer`  
    （可选参数）玩家的最小日志输出等级，默认为1    
- 返回值：无

这是为了方便游戏内调试而设计的功能，输出到玩家的日志会被当作聊天消息，显示在目标玩家的屏幕上

<br>

 ### 输出日志函数

在设置完毕之后，你就可以用这里的函数输出日志了

`logger.log(data1,data2,...)` -> 输出普通文本  
`logger.debug(data1,data2,...)` -> 输出调试信息  
`logger.info(data1,data2,...)`  -> 输出提示信息  
`logger.warn(data1,data2,...)`  -> 输出警告信息  
`logger.error(data1,data2,...)`  -> 输出错误信息  
`logger.fatal(data1,data2,...)`  -> 输出严重错误信息

- 参数：
  - 待输出的变量或者数据  
    可以是任意类型，参数数量可以是任意个
- 返回值：无

其中，**普通文本**在输出的时候会按照原样输出，而其他的各个输出接口都会在日志内容前面附加上**当前时间和日志类型**  
例如：你调用`logger.error("Fail to transport the player")`  
日志输出的结果是 

```
[2021-05-21 19:41:03 Error] Fail to transport the player
```

<br>

### 其他的一些设置项

除此之外，还有其他的一些设置项，用来改变输出日志的格式

#### 设置自定义日志消息标头  

`logger.setTitle(title)`

- 参数：
  - title : `String`  
    设置的自定义标头
- 返回值：无

「标头」为日志输出条目开头的文字，用来直观地区分日志的输出源。  
默认情况下，消息标头默认为空，即输出时没有标头。

例如：设置自定义标头为`logger.setTitle("LiteXLoader")`  
则在接下来的日志输出将变为形如：  

```
[LiteXLoader] [2021-05-21 19:41:03 Error] Fail to transport the player
```

如果在设置之后想要关闭标头，请执行`logger.setTitle("")`

<br>

#### 统一修改最小日志输出等级

`logger.setLogLevel(level)`

- 参数：
  - level : `Number`  
    日志的最小输出等级    
- 返回值：无

统一重设各种输出方向的最小日志输出等级  

<br>

------

## 💡 插件加载相关 API

这里提供了一些与加载器操作相关的接口。

### 获取LiteXLoader加载器版本

`lxl.version()`

- 返回值：加载器版本号，格式`主版本.次版本.开发版本`。如`1.0.1`
- 返回值类型： `String`

<br>

### 列出所有已加载的插件

`lxl.listPlugins()`

- 返回值：已加载的所有的插件名字列表
- 返回值类型： `Array<String,String,...>`

<br>

### 远程函数调用

为了可以让开发者开发的前置插件能够为其他插件提供接口和服务，这里提供了远程函数调用功能，让一个LXL插件可以调用另一个插件中已有的函数。

#### 导出函数

首先，为了你的插件中的函数可以被其他插件定位，你首先将你插件中的某些函数导出，让别人可以通过名字找到你的接口所在。使用这个函数来导出你想要共享的函数

`lxl.export(func,name)`

- 参数：
  - func : `Function`  
    要导出的函数
  - name : `String`  
    函数的导出名称。其他插件根据导出名称来调用这个函数
- 返回值：是否设置成功
- 返回值类型： `Boolean`

<br>

#### 远程调用函数

在前置插件设置过函数的导出名称之后，你就可以用这个函数来调用它里面的函数了。

`lxl.remoteCall(func,para1,para2,...)`

- 参数：
  - func : `String`  
    要调用的函数的导出名称
  - para1, para2, ... : `指定类型`  
    你要向目标函数传递的参数，参数数量以目标函数要求的参数数量为准  
    传递参数时，可以传递的数据类型有：   
    `Integer` `Float` `String` `Boolean` `Array` `Object `  
    其中，`Array` 和 `Object` 内部仅能嵌套上面出现的这些元素
- 返回值：调用的函数执行的返回结果
- 返回值类型： `任意类型`

当然，执行这个函数的前提是你要调用的前置插件已经被LXL加载。因此，你可能需要用下面的函数来设置依赖库，让你需要的前置插件被优先加载，保证执行成功

<br>

### 设置插件依赖库

有的时候，你需要确保某些插件在你自己的插件之前加载，以使用他们提供的前置服务，我们称这些前置插件为**依赖库**。

为此，LXL提供了下面的接口来提前加载插件所需要的依赖库，从本地文件，甚至可以从远程HTTP地址下载你所需的依赖库文件

`lxl.require(path[,remotePath])`

- 参数：
  - path : `String`  
    依赖库文件名（如`addplugin.js`)
  - remotePath : `String`  
    （可选参数）如果未找到这个依赖库，将尝试从这个地址下载所需要的依赖库文件并加载  
    如果下载失败，同样将返回加载失败。

- 返回值：是否加载依赖库成功
- 返回值类型： `Boolean`

注：如果出现循环依赖的情况，LXL将报错并返回失败。请注意避免循环依赖  
另外，依赖库文件的远程下载使用HTTP协议，插件作者可以将代码托管在GitHub或Gitee等稳定的大型网站上，并将外链提供给其他开发者以供远程下载使用。

<br>

[<< 返回目录](Development.md)